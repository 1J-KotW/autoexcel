Ниже отдельное ТЗ именно под «пункт 3» — автоматическое актуализирование цен и работа с разными заказчиками. Пишу так, чтобы это можно было отдать как отдельный подпроект.

***

## 1. Цель доработки

Добавить к уже существующей системе (сметы + справочник материалов):

1. Возможность **автоматически обновлять цены** материалов:
   - из файлов прайсов/счетов поставщиков (Excel/CSV/др. табличные форматы);
   - из веб‑сайтов поставщиков (парсинг).  
2. Возможность **использовать единый справочник** для разных заказчиков, у которых:
   - различаются форматы смет;
   - отличаются названия одних и тех же материалов.  
3. При этом не ломать текущую логику пунктов 1–2 (автозаполнение цен и стоимости работ), а расширить её.

***

## 2. Требования к модели данных (расширение текущего справочника)

### 2.1. Материалы (уточнение)

Сущность `Material` (или аналог) дополняется:

Обязательные поля (часть уже есть):

- `id` — PK;  
- `name_canonical` — каноническое (нормализованное) название материала;  
- `unit` — единица измерения;  
- `work_rate` — базовая стоимость работ за единицу (при необходимости можно сделать зависимой от заказчика/проекта позже);  
- `category` — категория материала (по возможности);  
- `active` — признак актуальности записи.

Новые/уточняемые поля:

- `default_vendor_id` — основной поставщик для этого материала (опционально);  
- `extra_keys` / отдельная таблица «aliases» (см. ниже).

### 2.2. Алиасы/варианты названий для разных заказчиков

Нужна отдельная сущность, наподобие `MaterialAlias`:

Поля:

- `id`;  
- `material_id` — ссылка на `Material`;  
- `customer_id` — заказчик, для которого используется такое написание (может быть `NULL`, если это общий алиас);  
- `alias_name` — вариант названия (как встречается в сметах);  
- `source` — откуда взято:
  - `manual` — вручную добавлен;
  - `import` — из конкретного файла;
  - `ai` или `fuzzy` — добавлен автоматически.  

Задача: системно хранить «грязные» названия и всегда маппить их к `Material`.

### 2.3. Источники цен

Нужна таблица `PriceSource` или аналог:

- `id`;  
- `type` — тип источника:
  - `invoice` — счёт/прайс файл;
  - `website` — сайт;
  - `manual` — ручной ввод;  
- `name` — человекочитаемое название (например, «Прайс Поставщик А 01.03.2026»);  
- `customer_id` — заказчик (если прайс специфичен для него, иначе `NULL`);  
- `vendor_id` — поставщик (если есть модель поставщика);  
- `doc_date` — дата документа/прайса;  
- `meta` — JSON/строка с произвольными метаданными (путь к файлу, URL, настройки парсинга и т.п.).

### 2.4. История цен

Таблица `MaterialPrice` (частично у тебя уже концептуально есть):

- `id`;  
- `material_id`;  
- `price` — цена за единицу;  
- `currency`;  
- `price_date` — дата, на которую распространяется цена;  
- `source_id` — ссылка на `PriceSource`;  
- `is_active` — флаг «актуальная/используемая» (для ускорения выборки);  
- опционально `valid_from`, `valid_to` — если нужны интервалы.

Логика выборки:  
для расчёта по дате X (например, дата сметы) берём **последнюю по времени** цену \(`price_date <= X`\) с нужными фильтрами (по заказчику/источнику/поставщику — по правилам, описанным ниже).

***

## 3. Импорт цен из файлов (прайсы/счета)

### 3.1. Входные данные

- Один или несколько файлов в формате:
  - Excel (xslx/xls);
  - CSV;
  - (опционально) другие табличные форматы.  
- В каждом файле есть как минимум:
  - Наименование материала (как у поставщика);
  - Цена за единицу;
  - Ед. изм. (желательно, но может отсутствовать или отличаться);
  - Дата прайса/счёта — либо есть в файле, либо задаётся пользователем при импорте.

### 3.2. Обработка

1. Пользователь выбирает:
   - файл прайса;
   - поставщика (если используется сущность `Vendor`);
   - дату прайса (если её нет в файле).  
2. Система создаёт запись в `PriceSource`.  
3. Для каждой строки прайса:
   - Парсит поля (название, цена, ед. изм., артикул — если есть);  
   - Пытается сопоставить строку с `Material`:
     - по артикулу (если структура справочника его хранит);
     - по каноническому названию;
     - по алиасам (`MaterialAlias`);
     - при необходимости — по нечеткому совпадению.  
   - Варианты результата:
     1. Материал найден однозначно:
        - создаётся запись в `MaterialPrice`;
        - при необходимости добавляется/обновляется алиас (название из прайса).  
     2. Найдено несколько кандидатов:
        - строка помечается как «неоднозначная»;
        - сохраняется в таблицу «подбор/разрешение конфликтов» (для последующего ручного решения);  
     3. Материал не найден:
        - строка попадает в список «неопознанные»;
        - пользователь позже либо:
          - создаёт новый `Material` и привязывает эту строку;
          - маппит её к существующему материалу.  

4. По завершении импорта:
   - должно быть минимум:
     - записаны цены для успешно сопоставленных материалов;
     - сформирован отчёт с «проблемными» позициями:
       - не найдено соответствия;
       - несколько кандидатов.

***

## 4. Парсинг цен с сайта поставщика

### 4.1. Общие требования

- Реализовать модуль, который по конфигурации на конкретного поставщика может:
  - обращаться к его сайту (HTTP/HTTPS);
  - находить товары (по артикулу или названию);
  - извлекать актуальную цену;
  - сохранять её в `MaterialPrice` с указанием `PriceSource` типа `website`.  

- Структура сайта должна быть вынесена в конфиг (чтобы при изменении верстки не пришлось менять весь код):
  - базовый URL;
  - способ поиска (URL с параметром, POST‑форма и т.п.);
  - CSS‑селекторы или XPath для вытаскивания цены;
  - валюта, НДС, округления.

### 4.2. Процесс обновления

1. Пользователь/скрипт запускает процедуру «Обновить цены с сайта Поставщик X».  
2. Система:
   - выбирает список материалов, для которых:
     - указан данный поставщик;
     - или отмечены как связанные с этим поставщиком;  
   - по каждому материалу:
     - формирует запрос (по артикулу, названию и т.д.);
     - парсит страницу;
     - вытаскивает цену.  
3. На каждую успешную цену:
   - создаёт/обновляет `PriceSource` (если нужно);
   - создаёт `MaterialPrice` с актуальной датой (`price_date = сегодня`);  
4. В случае ошибок:
   - логирует проблемы (не найден товар, изменилась структура страницы, статус 403/500 и т.д.);
   - не ломает весь процесс — просто помечает конкретный материал как «ошибка парсинга».

***

## 5. Выбор актуальной цены для расчёта смет

Для взаимодействия с уже реализованной логикой пунктов 1–2 нужно определить **правила выбора цены**:

### 5.1. Параметры выбора

На входе расчета сметы должны передаваться (явно или неявно):

- `calculation_date` — дата расчета (по умолчанию — текущая, но можно задать дату счёта/контракта);  
- `customer_id` — заказчик (если есть многозаказная архитектура);  
- опционально `preferred_vendor` / приоритет источников.

### 5.2. Алгоритм выбора цены

Для каждой строки сметы, сопоставленной с `Material`:

1. Собрать все цены (`MaterialPrice`), у которых:
   - `material_id` совпадает;
   - `price_date <= calculation_date`.  
2. Приоритеты:
   - сначала фильтруем по приоритету источников, например:
     1. `invoice` для конкретного заказчика/проекта;
     2. `invoice` общие/по поставщику;
     3. `website`;
     4. `manual`.  
   - затем выбираем запись с максимальным `price_date`.  
3. Если цена не найдена:
   - оставить ячейку пустой;
   - пометить строку как «нет актуальной цены»;
   - включить в отчёт.

***

## 6. Поддержка разных заказчиков и форматов смет

### 6.1. Сущность «Заказчик»

Вводится `Customer`:

- `id`;  
- `name`;  
- опционально настройки:
  - prefered_price_source_type (например, только из своих счетов);
  - валюта/НДС по умолчанию;
  - маппинги колонок для его стандартных шаблонов Excel.

### 6.2. Маппинг структур смет

Для каждого заказчика можно задать:

- шаблон/правила:
  - какая колонка в их файлах — «Наименование»;
  - какая — «Код/артикул»;
  - какая — «Количество» и т.д.  

Это позволит:

- подключать новых заказчиков без переписывания кода;
- по конфигу «обучать» систему их формату.

***

## 7. Пользовательские сценарии для пункта 3

1. **Загрузка нового прайса от поставщика/заказчика**  
   - Пользователь выбирает файл, дату, поставщика и (если нужно) заказчика.  
   - Система:
     - импортирует строки;
     - сопоставляет с материалами;
     - обновляет/дополняет историю цен;
     - выдаёт отчёт по проблемным позициям.

2. **Обновление цен с сайта поставщика**  
   - Пользователь запускает процедуру обновления для одного или нескольких поставщиков.  
   - Система парсит сайт, обновляет `MaterialPrice`, логирует ошибки.

3. **Расчёт сметы с учётом даты**  
   - Пользователь выбирает смету, заказчика и дату расчёта.  
   - Система:
     - сопоставляет материалы со справочником;
     - для каждого подбирает актуальную цену по правилам;
     - заполняет Excel соответствующими значениями.

***

## 8. Нефункциональные требования для блока 3

- Не ломать существующую функциональность пунктов 1–2.  
- Логирование всех операций импорта/парсинга/обновления цен.  
- Возможность отката (например, пометить пакет цен как неактуальный).  
- Готовность к подключению модулей:
  - нечеткого поиска;

